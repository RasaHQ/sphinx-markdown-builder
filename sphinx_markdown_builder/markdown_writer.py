import json
import posixpath

from pytablewriter import MarkdownTableWriter
from sphinx.util import logging
import yaml

from .depth import Depth
from .doctree2md import Translator, Writer
from docutils import nodes
from pydash import _
import html2text
import os
import sys

h = html2text.HTML2Text()

class MarkdownTranslator(Translator):
    depth = Depth()
    enumerated_count = {}

    def __init__(self, document, builder=None):
        Translator.__init__(self, document, builder=None)
        self.builder = builder
        self.title = None
        self.has_tabs = False
        self.table_entries = []
        self.tables = []
        self.is_in_table_head = False

    def visit_document(self, node):
        pass

    @property
    def pageid(self):
        return self.builder.current_docname.split("/")[-1]

    def depart_document(self, node):
        variables = {
            "id": self.pageid,
            "title": self.title,
            "sidebar_label": self.title,
        }
        variables_yaml = yaml.safe_dump(variables)
        frontmatter = '---\n' + variables_yaml + '---\n'
        self.add(frontmatter, section='head')
        if self.has_tabs:
            self.add("import Tabs from '@theme/Tabs';\n"
                     "import TabItem from '@theme/TabItem';\n",
                     section="head")

    def visit_title(self, node):
        if self.section_level == 1 and self.title is None:
            self.title = node.astext()
            raise nodes.SkipNode
        else:
            self.add(self.section_level * '#' + ' ')

    def visit_container(self, node):
        # the description of the class/method
        if "sphinx-tabs" in node.get("classes", []):
            self.has_tabs = True
            tabs = []

            self.start_level("  ")

            for child in node.children:
                label = child[0].astext()
                value = label.lower().replace("-","").replace("-","").replace(" ","")
                tabs.append({"label": label, "value": value})
                self.add(f"<TabItem value=\"{value}\">\n\n")
                child[1].walkabout(self)
                self.add(f"</TabItem>\n")

            level = self.indent_levels.pop()
            values = json.dumps(
                [{"label": t["label"], "value": t["value"]} for t in tabs])
            self.add(f"<Tabs values={{{values}}} defaultValue=\"{tabs[0]['value']}\">\n")
            level.write()
            self.add("</Tabs>\n\n")
            raise nodes.SkipNode

    def depart_container(self, node):
        # the description of the class/method
        pass

    def visit_target(self, node):
        if "refid" in node and node["refid"] != self.pageid:
            # only add link nodes for links other than the page itselfs
            self.add(f"""<a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor" id="{node['refid']}"></a>\n\n""")

    def depart_target(self, node):
        pass

    def visit_desc(self, node):
        if node.get("desctype") == "class":
            # these are descriptions generated by .. autoclass::
            # directive, we will generate them separately, they will only mess up
            # the parser
            self.add("- SKIPPED CLASS DOCUMENTATION -")
            raise nodes.SkipNode

    def depart_desc(self, node):
        pass

    def visit_desc_annotation(self, node):
        # annotation, e.g 'method', 'class'
        pass

    def depart_desc_annotation(self, node):
        # annotation, e.g 'method', 'class'
        pass

    def visit_desc_addname(self, node):
        # module preroll for class/method
        pass

    def depart_desc_addname(self, node):
        # module preroll for class/method
        pass

    def visit_desc_name(self, node):
        # name of the class/method
        # Escape "__" which is a formating string for markdown
        if node.rawsource.startswith("__"):
            self.add('\\')
        pass

    def depart_desc_name(self, node):
        # name of the class/method
        pass

    def visit_desc_content(self, node):
        # the description of the class/method
        pass

    def depart_desc_content(self, node):
        # the description of the class/method
        pass

    def visit_desc_signature(self, node):
        # the main signature of class/method
        # We dont want methods to be at the same level as classes,
        # If signature has a non null class, thats means it is a signature
        # of a class method
        if "class" in node.attributes and node.attributes["class"]:
            self.add(f'\n#### {node.attributes["fullname"]}\n')
        elif "fullname" in node.attributes:
            self.add(f'\n### {node.attributes.get("fullname")}\n')
        else:
            raise nodes.SkipNode

    def depart_desc_signature(self, node):
        # the main signature of class/method
        self.add('**:\n')

    def visit_desc_parameterlist(self, node):
        # method/class ctor param list
        pass

    def depart_desc_parameterlist(self, node):
        # method/class ctor param list
        pass

    def visit_desc_parameter(self, node):
        # single method/class ctr param
        pass

    def depart_desc_parameter(self, node):
        # single method/class ctr param
        # if there are additional params, include a comma
        if node.next_node(descend=False, siblings=True):
            self.add(', ')

    # list of parameters/return values/exceptions
    #
    # field_list
    #   field
    #       field_name (e.g 'returns/parameters/raises')
    #

    def visit_field_list(self, node):
        pass

    def depart_field_list(self, node):
        pass

    def visit_field(self, node):
        self.add('\n')

    def depart_field(self, node):
        self.add('\n')

    def visit_field_name(self, node):
        # field name, e.g 'returns', 'parameters'
        self.add('* **')

    def depart_field_name(self, node):
        self.add('**')

    def visit_literal_strong(self, node):
        self.add('**')

    def depart_literal_strong(self, node):
        self.add('**')

    def visit_literal_emphasis(self, node):
        self.add('*')

    def depart_literal_emphasis(self, node):
        self.add('*')

    def visit_title_reference(self, node):
        pass

    def depart_title_reference(self, node):
        pass

    def visit_versionmodified(self, node):
        # deprecation and compatibility messages
        # type will hold something like 'deprecated'
        self.add('**%s:** ' % node.attributes['type'].capitalize())

    def depart_versionmodified(self, node):
        # deprecation and compatibility messages
        pass

    def visit_warning(self, node):
        """Sphinx warning directive."""
        self.add(':::caution\n')

    def depart_warning(self, node):
        """Sphinx warning directive."""
        self.add(':::\n\n')

    def visit_runnable_node(self, node):
        """Handle the .. runnable:: directive."""
        # TODO: add a different component?
        self.add('```bash\n')
        self.add(node.get("code", ""))
        self.ensure_eol()

    def depart_runnable_node(self, node):
        """Handle the .. runnable:: directive."""
        self.add('```\n')

    def visit_edit_node(self, node):
        """Handle the .. edit-link:: directive."""
        # TODO: add a different component (these are the Edit on Github links)?
        pass

    def depart_edit_node(self, node):
        """Handle the .. edit-link:: directive."""
        pass

    def visit_glossary(self, node):
        """Handle the .. glossary:: directive."""
        # TODO: add a different component to handle glossary? or at least iterate
        #       properly over elements
        pass

    def depart_glossary(self, node):
        """Handle the .. glossary:: directive."""
        pass

    def visit_definition_list_item(self, node):
        """
        Handle each item in the .. glossary:: directive
        """
        if node.parent.parent.tagname == "glossary":
            self.add("## ")

    def visit_topic(self, node):
        """Handle the .. contents:: directive."""
        # don't think we need this, in rst this adds a table of contents, but we
        # already have that on the right hand side
        raise nodes.SkipNode

    def depart_topic(self, node):
        """Handle the .. contents:: directive."""
        pass

    def visit_copyable_node(self, node):
        """Handle the .. copyable:: directive."""
        # there is a copy button in all code blocks, so we can use a normal code block
        self.add('```bash\n')
        self.add(node.get("code", ""))
        self.ensure_eol()

    def depart_copyable_node(self, node):
        """Handle the .. copyable:: directive."""
        pass

    def visit_juniper_node(self, node):
        """Handle the .. juniper:: directive."""
        # don't think we need this, this is only used in rasa-tutorial.rst
        # and should be replaced by new onboarding
        pass

    def depart_juniper_node(self, node):
        """Handle the .. juniper:: directive."""
        pass

    def _normalize_relative_path(self, path):
        this_dir = posixpath.dirname(self.builder.current_docname)
        if this_dir:
            return posixpath.normpath('{}/{}'.format(this_dir, path or ""))
        else:
            return path

    def visit_button_node(self, node):
        """Handle the .. button:: directive."""

        url = self._normalize_relative_path(node.get("link"))
        self.add(f'\n<a class="button button--outline button--secondary button--lg" href="{url}">{node.get("text")}</a>\n')

    def depart_button_node(self, node):
        """Handle the .. button:: directive."""
        pass

    def visit_conversations_node(self, node):
        """Handle the .. conversations:: directive"""
        conversations = yaml.load(node.get("content", ""), Loader=yaml.FullLoader)
        # TODO: create separate elements for conversation elements
        self.add(f"```\n{node.get('content')}\n```\n")

    def depart_conversations_node(self, node):
        """Handle the .. conversations:: directive"""
        pass

    def visit_bubble_node(self, node):
        """Handle the .. chat-bubble:: directive"""
        sender = node.get("sender", "")
        text = node.get("text")
        # TODO: use better component to render chat bubbles
        self.add(f"```\n{sender.upper()}: {text}\n```\n")

    def depart_bubble_node(self, node):
        """Handle the .. chat-bubble:: directive"""
        pass

    def visit_admonition(self, node):
        self.add(f':::tip {node.children[0].astext()}\n')
        for child in node.children[1:]:
            child.walkabout(self)
        self.add(':::\n\n')
        raise nodes.SkipNode

    def depart_admonition(self, node):
        pass

    def visit_note(self, node):
        """Sphinx note directive."""
        self.add(':::note\n')

    def depart_note(self, node):
        """Sphinx note directive."""
        self.add(':::\n\n')

    def visit_rubric(self, node):
        """Sphinx Rubric, a heading without relation to the document sectioning
        http://docutils.sourceforge.net/docs/ref/rst/directives.html#rubric."""
        self.add('### ')

    def depart_rubric(self, node):
        """Sphinx Rubric, a heading without relation to the document sectioning
        http://docutils.sourceforge.net/docs/ref/rst/directives.html#rubric."""
        self.add('\n\n')

    def visit_image(self, node):
        """Image directive."""
        uri = node.attributes['uri']
        doc_folder = os.path.dirname(self.builder.current_docname)
        if uri.startswith(doc_folder):
            # drop docname prefix
            uri = self._normalize_relative_path("../" + uri)

        if uri.startswith("_static/images"):
            # drop old sphinx prefix, images moved to `static/img`
            uri = "../../img" + uri[len("_static/images"):]

        self.add('\n\n![image](%s)\n\n' % uri)

    def depart_image(self, node):
        """Image directive."""
        pass

    def visit_autosummary_table(self, node):
        """Sphinx autosummary See http://www.sphinx-
        doc.org/en/master/usage/extensions/autosummary.html."""
        pass

    def depart_autosummary_table(self, node):
        """Sphinx autosummary See http://www.sphinx-
        doc.org/en/master/usage/extensions/autosummary.html."""
        pass

    ################################################################################
    # tables
    #
    # docutils.nodes.table
    #     docutils.nodes.tgroup [cols=x]
    #       docutils.nodes.colspec
    #
    #       docutils.nodes.thead
    #         docutils.nodes.row
    #         docutils.nodes.entry
    #         docutils.nodes.entry
    #         docutils.nodes.entry
    #
    #       docutils.nodes.tbody
    #         docutils.nodes.row
    #         docutils.nodes.entry

    def visit_math_block(self, node):
        pass

    def depart_math_block(self, node):
        pass

    def visit_raw(self, node):
        self.descend('raw')

    def depart_raw(self, node):
        self.ascend('raw')

    def visit_table(self, node):
        self.tables.append(MarkdownTableWriter())

    def depart_table(self, node):
        table = self.tables.pop()
        if not table.headers and table.value_matrix:
            table.headers = [""] * len(table.value_matrix[0])
        self.ensure_eol()
        self.add(table.dumps())
        self.add("\n")

    def visit_tabular_col_spec(self, node):
        pass

    def depart_tabular_col_spec(self, node):
        pass

    def visit_colspec(self, node):
        pass

    def depart_colspec(self, node):
        pass

    def visit_tgroup(self, node):
        self.descend('tgroup')

    def depart_tgroup(self, node):
        self.ascend('tgroup')

    def visit_thead(self, node):
        if not len(self.tables):
            raise nodes.SkipNode
        self.is_in_table_head = True

    def depart_thead(self, node):
        self.tables[-1].headers = self.table_entries
        self.table_entries = []
        self.is_in_table_head = False

    def visit_tbody(self, node):
        if not len(self.tables):
            raise nodes.SkipNode

    def depart_tbody(self, node):
        pass

    def visit_row(self, node):
        pass

    def depart_row(self, node):
        if not self.is_in_table_head:
            self.tables[-1].value_matrix.append(self.table_entries)
            self.table_entries = []

    def visit_entry(self, node):
        inner = MarkdownTranslator(self.document, self.builder)
        for child in node.children:
            child.walkabout(inner)
        self.table_entries.append(inner.astext() or "")
        raise nodes.SkipNode

    def depart_entry(self, node):
        pass

    def visit_enumerated_list(self, node):
        self.depth.descend('list')
        self.depth.descend('enumerated_list')

    def depart_enumerated_list(self, node):
        self.enumerated_count[self.depth.get('list')] = 0
        self.depth.ascend('enumerated_list')
        self.depth.ascend('list')

    def visit_bullet_list(self, node):
        self.depth.descend('list')
        self.depth.descend('bullet_list')

    def depart_bullet_list(self, node):
        self.depth.ascend('bullet_list')
        self.depth.ascend('list')

    def visit_list_item(self, node):
        self.depth.descend('list_item')
        depth = self.depth.get('list')

        if node.parent.tagname == 'enumerated_list':
            if depth not in self.enumerated_count:
                self.enumerated_count[depth] = 1
            else:
                self.enumerated_count[depth] = self.enumerated_count[depth] + 1
            marker = str(self.enumerated_count[depth]) + '. '
        else:
            marker = "* "

        depth_padding = ' ' * ((depth - 1) * 2 + len(marker))

        self.ensure_eol()
        self.start_level(depth_padding, first_prefix=depth_padding[len(marker):]+ marker)

        for child in node.children:
            if child.tagname == "block_quote":
                # skip this block quote, but keep the children
                for grandchild in child.children:
                    grandchild.walkabout(self)
            else:
                child.walkabout(self)
        self.finish_level()
        self.depth.ascend('list_item')
        raise nodes.SkipNode

    def depart_list_item(self, node):
        self.depth.ascend('list_item')

    def descend(self, node_name):
        self.depth.descend(node_name)

    def ascend(self, node_name):
        self.depth.ascend(node_name)

class MarkdownWriter(Writer):
    translator_class = MarkdownTranslator
